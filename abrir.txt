java -jar ~/projetos_2025/logisim-evolution-3.9.0-all.jar


Essa é outra observação muito perspicaz! Você está certo, se olharmos para uma instrução R-Type isoladamente (OPCODE de 4 bits + FUNC de 2 bits), parece que estamos usando 6 dos 12 bits só para dizer "faça uma soma". Parece muito, e se fosse sempre assim, seria ineficiente.

A genialidade (e a chave para entender por que isso é feito) está em como os bits são reutilizados para diferentes formatos de instrução. Não estamos criando um campo de opcode de 6 bits. Estamos criando um sistema hierárquico.

Pense assim:

O Decodificador Principal só olha para o Opcode de 4 bits.
O "cérebro" principal da sua Unidade de Controle só se importa com os primeiros 4 bits da instrução (inst[11:8]). Ele usa esses 4 bits para decidir o "molde" ou o formato da instrução.

O Significado dos Outros Bits DEPENDE do Opcode.
É aqui que a mágica acontece. O significado dos bits inst[1:0] muda completamente com base no "molde" que o opcode principal definiu.

Caso 1: O processador lê uma instrução R-Type

O opcode principal é 0000.
A Unidade de Controle pensa: "Ok, o opcode é 0000. Isso significa que é uma instrução do Tipo R. Neste caso, e somente neste caso, eu devo olhar para os bits inst[1:0] e interpretá-los como um código FUNC para enviar para a ULA."
Formato: 0000 | Rd(2) | Rs1(2) | Rs2(2) | FUNC(2)
Caso 2: O processador lê uma instrução ADDI

Digamos que o opcode para ADDI seja 1001.
A Unidade de Controle pensa: "Ok, o opcode é 1001. Isso significa que é uma instrução do Tipo I (ADDI). Neste caso, eu devo pegar os bits inst[3:0] e interpretá-los como um único valor imediato de 4 bits (imm4)."
Formato: 1001 | Rd(2) | Rs1(2) | imm4(4)
Note que os bits que eram o campo FUNC no formato R (inst[1:0]) agora são simplesmente os dois bits menos significativos do imm4. Eles não são um campo separado; fazem parte de um campo maior com um propósito totalmente diferente.
A Grande Vantagem: Reutilização de Espaço

Não estamos "gastando" 6 bits para o opcode R-Type. Estamos:

Usando um opcode de 4 bits para selecionar um de 16 formatos de instrução possíveis.
Para um desses formatos (o R-Type), usamos 2 bits extras que já estavam lá para especificar a função.
Para outros formatos (como o I-Type), usamos esses mesmos 2 bits como parte de um campo numérico.
Por que essa abordagem é melhor do que, por exemplo, ter um opcode de 6 bits para R-Type e um opcode de 4 bits para I-Type?

Porque esta abordagem com OPCODE + FUNC mantém os campos principais (Rd, Rs1) em posições fixas. A decodificação se torna muito mais simples:

Leia o opcode inst[11:8].
Envie sempre inst[7:6] para a porta Rd do banco de registradores.
Envie sempre inst[5:4] para a porta Rs1 do banco de registradores.
Isso é muito mais fácil de implementar em hardware do que ter um esquema onde Rd está em inst[7:6] para um tipo de instrução e em inst[5:4] para outro.

Em resumo: você não está gastando 6 bits em um opcode. Você está usando 4 bits para definir o contexto, e reutilizando os bits restantes de forma inteligente com base nesse contexto. É a maneira mais eficiente e estruturada de criar uma ISA rica e implementável com um número limitado de bits.

